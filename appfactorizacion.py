# -*- coding: utf-8 -*-
"""AppFactorizacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JtT3XSSiIv62U7UhvYG5lALUrpBZTfaR
"""

import streamlit as st
import math

# Función que calcula el residuo de la división de dos enteros gaussianos
def modulo_intgauss(z, w):
    return z - w * complex(round((z/w).real), round((z/w).imag))

# Función para factorizar un entero positivo
def fact_int(n):
    factorizacion = []
    for i in [2] + list(range(3, int(n**0.5) + 1, 2)):
        while n % i == 0:
            factorizacion.append(i)
            n //= i
    if n > 1:
        factorizacion.append(n)
    return factorizacion

# Matriz de factores y exponentes
def matrix_fact(vector):
    return {factor: vector.count(factor) for factor in set(vector)}

# Función que factoriza un primo de la forma 4n+1
def teo_fermat(p):
    for i in range(1, int(math.sqrt(p)) + 1):
        j_squared = p - i**2
        j = int(math.sqrt(j_squared))
        if j**2 == j_squared:
            return [complex(i, j), complex(i, -j)]

# Función que factoriza primos gaussianos
def teo_fermat_gauss(diccionario, z):
    diccionario1 = {}
    zAux = z
    for factor, exp in diccionario.items():
        diccionario1[factor] = exp
        if factor % 4 == 3:
            diccionario1[factor] = exp // 2
        if factor == 2:
            diccionario1[1+1j] = diccionario1.pop(factor)
        if factor % 4 == 1:
            k = 0
            while modulo_intgauss(zAux, factor) == 0+0j:
                zAux = zAux / factor
                k += 1
            factores = teo_fermat(factor)
            if modulo_intgauss(z, factores[0]) == 0:
                diccionario1[factor] -= k
                diccionario1[factores[0]] = diccionario1.pop(factor)
                diccionario1[factores[1]] = k
            else:
                diccionario1[factores[1]] = diccionario[factor] - k
                diccionario1[factores[0]] = diccionario1.pop(factor)
                diccionario1[factores[0]] = k
    for a, b in diccionario1.items():
        z = z / (a**b)
    z = complex(round(z.real), round(z.imag))
    count1 = 0
    while (0+1j)**count1 != z:
        count1 += 1
    diccionario1[0+1j] = count1
    return diccionario1

# Interfaz de Streamlit
st.title("Factorización de Enteros Gaussianos")

z_input = st.text_input("Ingrese el entero gaussiano en la forma a+bj con a,b números enteros", value="3+4j")

try:
    z = complex(z_input.replace(" ", "").replace("j", "j"))
    norma = int((z * z.conjugate()).real)
    mi_diccionario = teo_fermat_gauss(matrix_fact(fact_int(norma)), z)
    fact = ' * '.join([f"({key})^{value}" for key, value in mi_diccionario.items()])
    st.success(f"Factorización: {z} = {fact}")

    #comprobacion = math.prod(a**b for a, b in mi_diccionario.items())
    #st.write(f"Comprobación: {comprobacion}")
except ValueError as e:
    st.error(f"Debe ser un entero gaussiano de la forma a+bj con a,b números enteros")
except Exception as e:
    st.error(f"Ocurrió un error: {e}")
